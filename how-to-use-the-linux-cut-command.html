<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>How to Use the Linux cut Command - VivaX</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content="The Linux cut command lets you extract portions of text from files or data streams. It's especially useful for working with delimited data, such as CSV files. Here's what you need to know. The cut command is a veteran of the Unix world, making its debut in 1982 as part of AT&amp;amp;T System III UNIX."><meta name=robots content="index,follow,noarchive"><meta property="og:title" content="How to Use the Linux cut Command"><meta property="og:description" content="The Linux cut command lets you extract portions of text from files or data streams. It's especially useful for working with delimited data, such as CSV files. Here's what you need to know. The cut command is a veteran of the Unix world, making its debut in 1982 as part of AT&amp;amp;T System III UNIX."><meta property="og:type" content="article"><meta property="og:url" content="/how-to-use-the-linux-cut-command.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-03-12T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-12T00:00:00+00:00"><meta itemprop=name content="How to Use the Linux cut Command"><meta itemprop=description content="The Linux cut command lets you extract portions of text from files or data streams. It's especially useful for working with delimited data, such as CSV files. Here's what you need to know. The cut command is a veteran of the Unix world, making its debut in 1982 as part of AT&amp;amp;T System III UNIX."><meta itemprop=datePublished content="2024-03-12T00:00:00+00:00"><meta itemprop=dateModified content="2024-03-12T00:00:00+00:00"><meta itemprop=wordCount content="1710"><meta itemprop=keywords content><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=https://assets.cdnweb.info/hugo/mainroad/css/style.css><link rel="shortcut icon" href=./favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=./index.html title=VivaX rel=home><div class="logo__item logo__text"><div class=logo__title>VivaX</div></div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>How to Use the Linux cut Command</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2024-03-12T00:00:00Z>March 12, 2024</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=./categories/blog/ rel=category>blog</a></span></div></div></header><div class="content post__content clearfix"><h3>Quick Links</h3><ul class=table-content-level-1><li><a href=#>The cut Command</a></li></ul><ul class=table-content-level-1><li><a href=#>First Steps With cut</a></li></ul><ul class=table-content-level-1><li><a href=#>Using cut With Characters</a></li></ul><ul class=table-content-level-1><li><a href=#>Using cut With Delimited Data</a></li></ul><ul class=table-content-level-1><li><a href=#>Piping cut Into cut</a></li></ul><ul class=table-content-level-1><li><a href=#>The Output Delimiter</a></li></ul><ul class=table-content-level-1><li><a href=#>An Oldie but Goldie</a></li></ul><h3 class="title icon i-list">Key Takeaways</h3><ul><li>The Linux cut command allows you to extract portions of text from files or data streams.</li><li>Cut can work with bytes, characters, or delimited fields, allowing you to select specific portions of text based on your criteria.</li><li>Cut can be combined with other utilities like greg to perform more complex operations</li></ul><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>The Linux <code>cut</code> command lets you extract portions of text from files or data streams. It's especially useful for working with delimited data, such as <a href=#>CSV files</a>. Here's what you need to know.</p><h2 id=the-cut-command>The cut Command</h2><p>The <code>cut</code> command is a veteran of the <a href=#>Unix</a> world, making its debut in 1982 as part of AT&T System III UNIX. Its purpose in life is to snip out sections of text from files or streams, according to the criteria that you set. Its syntax is as simple as its purpose, but it is this joint simplicity that makes it so useful.</p><p>In the time-honored UNIX way, by combining <code>cut</code> with other utilities <a href=#>such as <code>grep</code></a> you can create elegant and powerful solutions to challenging problems. While there are different versions of <code>cut</code>, we're going to discuss the standard GNU/Linux version. Be aware that other versions, notably the <code>cut</code> found in <a href=#>BSD</a> variants, don't include all the options described here.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>You can check which version is installed on your computer by issuing this command:</p><pre>cut --version</pre><p>If you see "GNU coreutils" in the output you're on the version we're going to describe in this article. All versions of <code>cut</code> have some of this functionality, but the Linux version has had enhancements added to it.</p><h2 id=first-steps-with-cut>First Steps With cut</h2><p>Whether we're <a href=#>piping information</a> into <code>cut</code> or using <code>cut</code> to <a href=#>read a file</a>, the commands we use are the same. Anything you can do to a stream of input with <code>cut</code> can be done on a line of text from a file, and vice versa. We can tell <code>cut</code> to work with bytes, characters, or delimited fields.</p><p>To select a single byte, we use the <code>-b</code> (byte) option and tell <code>cut</code> which byte or bytes we want. In this case, it is byte five. We're sending the string "how-to geek" into the <code>cut</code> command with a pipe, "|", from <code>echo</code> .</p><pre>echo 'how-to geek' | cut -b 5</pre><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong> <img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/1-2.png><p>The fifth byte in that string is "t", so <code>cut</code> responds by printing "t" in the terminal window.</p><p>To specify a range we use a hyphen. To extract bytes 5 through to—and including—11, we'd issue this command:</p><pre>echo 'how-to geek' | cut -b 5-11</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/2-2.png><p>You can supply multiple single bytes or ranges by separating them with commas. To extract byte 5 and byte 11, use this command:</p><pre>echo 'how-to geek' | cut -b 5,11</pre><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong> <img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/3-2.png><p>To get the first letter of each word we can use this command:</p><pre>echo 'how-to geek' | cut -b 1,5,8</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/4-2.png><p>If you use the hyphen without a first number, <code>cut</code> returns everything from position 1 up to the number. If you use the hyphen without a second number, <code>cut</code> returns everything from the first number to the end of the stream or line.</p><pre>echo 'how-to geek' | cut -b -6</pre><pre>echo 'how-to geek' | cut -b 8-</pre><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong> <img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/4-5.png><h2 id=using-cut-with-characters>Using cut With Characters</h2><p>Using <code>cut</code> with characters is pretty much the same as using it with bytes. In both cases, special care must be taken with complex characters. By using the <code>-c</code> (character) option, we tell <code>cut</code> to work in terms of characters, not bytes.</p><pre>echo 'how-to geek' | cut -c 1,5,8</pre><pre>echo 'how-to geek' | cut -c 8-11</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/5-3.png> <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>These work exactly as you'd expect. But take a look at this example. It's a six-letter word, so asking <code>cut</code> to return the characters from one to six should return the entire word. But it doesn't. It's one character short. To see the whole word we have to ask for the characters from one to seven.</p><pre>echo 'piñata' | cut -c 1-6</pre><pre>echo 'piñata' | cut -c 1-7</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/6-3.png><p>The issue is the character "ñ" is actually made up out of two bytes. We can see this quite easily. We've got a short <a href=#>text file</a> containing this line of text:</p><pre>cat unicode.txt</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/7-2.png> <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>We'll <a href=#>examine that file</a> with the <code>hexdump</code> utility. Using the <code>-C</code> (canonical) option gives us a table of hexadecimal digits with the <a href=#>ASCII equivalent</a> on the right. In the ASCII table, the "ñ" isn't shown, instead, there are dots representing two non-printable characters. These are the bytes highlighted in the <a href=#>hexadecimal</a> table.</p><pre>hexdump -C unicode.txt</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/8-2.png><p>These two bytes are used by the displaying program—in this case, <a href=#>the Bash shell</a>—to identify the "ñ." Many <a href=#>Unicode characters</a> use three or more bytes to represent a single character.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>If we ask for character 3 or character 4 we're shown the symbol for a non-printing character. If we ask for bytes 3 and 4, the shell interprets them as "ñ."</p><pre>echo 'piñata' | cut -c 3</pre><pre>echo 'piñata' | cut -c 4</pre><pre>echo 'piñata' | cut -c 3-4</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/9-2.png><h2 id=using-cut-with-delimited-data>Using cut With Delimited Data</h2><p>We can ask <code>cut</code> to split lines of text using a specified delimiter. By default, cut uses a tab character but it is easy to tell it to use whatever we want. The fields in the "/etc/passwd" file are separated by colons ":", so we'll use that as our delimiter and extract some text.</p><p>The portions of text between the delimiters are called fields, and are referenced just like bytes or characters, but they're preceded by the <code>-f</code> (fields) option. You can leave a space between the "f" and the digit, or not.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>The first command uses the <code>-d</code> (delimiter) option to tell cut to use ":" as the delimiter. It's going to pull the first field out of each line in the "/etc/passwd" file. That'll be a long list so we're using <code>head</code> with the <code>-n</code> (number) option to show the first five responses only. The second command does the same thing but uses <code>tail</code> to show us the last five responses.</p><pre>cut -d':' -f1 /etc/passwd | head -n 5</pre><pre>cut -d':' -f2 /etc/passwd | tail -n 5</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/11-2.png><p>To extract a selection of fields, list them as a comma-separated list. This command will extract fields one to three, five, and six.</p><pre>cut -d':' -f1-3,5,6 /etc/passwd | tail -n 5</pre><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong> <img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/12-2.png><p>By including <code>grep</code> in the command, we can look for lines that include "/bin/bash." The means we can list only those entries that have Bash as their default shell. That'll usually be the "normal" user accounts. We'll ask for fields from one to six because the seventh field is the default shell field and we already know what that is—we're searching for it.</p><pre>grep "/bin/bash" /etc/passwd | cut -d':' -f1-6</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/13-2.png> <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>Another way to include all fields apart from one is to use the <code>--complement</code> option. This inverts the field selection and shows everything that hasn't been requested. Let's repeat the last command but only ask for field seven. Then we'll run that command again with the <code>--complement</code> option.</p><pre>grep "/bin/bash" /etc/passwd | cut -d':' -f7</pre><pre>grep "/bin/bash" /etc/passwd | cut -d':' -f7 --complement</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/14-2.png><p>The first command finds a list of entries, but field seven gives us nothing to distinguish between them, so we don't know who the entries refer to. In the second command, by adding the <code>--complement</code> option we get everything except field seven.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><h2 id=piping-cut-into-cut>Piping cut Into cut</h2><p>Sticking with the "/etc/passwd" file, let's extract field five. This is the actual name of the user who <a href=#>owns the user account</a>.</p><pre>grep "/bin/bash" /etc/passwd | cut -d':' -f5</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/15-2.png><p>The fifth field has subfields separated by commas. They're rarely populated so they show up as a line of commas.</p><p>We can remove the commas by piping the output of the previous command into another invocation of <code>cut</code> . The second instance of <code>cut</code> uses the comma "," as its delimiter. The <code>-s</code> (only delimited) option tells <code>cut</code> to suppress results that don't have the delimiter in them at all.</p><pre>grep "/bin/bash" /etc/passwd | cut -d':' -s -f5 | cut -d',' -s -f1</pre><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong> <img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/16-2.png><p>Because the root entry doesn't have comma subfields in the fifth field it is suppressed, and we get the results we're after—a list of the names of the "real" users configured on this computer.</p><h2 id=the-output-delimiter>The Output Delimiter</h2><p>We've got a small file with some Comma Separated Values in them. The fields in this dummy data are:</p><ul><li><strong>ID</strong>: A database ID number</li><li><strong>First</strong>: The first name of the subject.</li><li><strong>Last</strong>: The last name of the subject.</li><li><strong>email</strong>: Their email address.</li><li><strong>IP Address</strong>: Their <a href=#>IP Address</a>.</li><li><strong>Brand</strong>: The brand of motor vehicle they drive.</li><li><strong>Model</strong>: The model of motor vehicle they drive.</li><li><strong>Year</strong>: The year their motor vehicle was built.</li></ul><pre>cat small.csv</pre><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong> <img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/10-2.png><p>If we tell cut to use the comma as the delimiter we can extract fields just like we did before. Sometimes you'll have a requirement to extract data from a file, but you don't want to have the field delimiter included in the results. Using the <code>--output-delimiter</code> we can tell cut what character—or in fact, character sequence—to use instead of the actual delimiter.</p><pre>cut -d ',' -f 2,3 small.csv</pre><pre>cut -d ',' -f 2,3 small.csv --output-delimiter=' '</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/17-1.png> <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>The second command tells <code>cut</code> to replace the commas with spaces.</p><p>We can take this further and use this feature to convert the output to a vertical list. This command uses a new line character as the output delimiter. Note the "$" that we need to include to have the newline character acted upon, and not interpreted as a literal sequence of two characters.</p><p>We'll use <code>grep</code> to filter out the entry for Morgana Renwick, and ask <code>cut</code> to print all fields from field two to the end of the record, and to use a newline character as the output delimiter.</p><pre>grep 'renwick' small.csv | cut -d ',' -f2- --output-delimiter=$''</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2021/12/18-1.png> <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><h2 id=an-oldie-but-goldie>An Oldie but Goldie</h2><p>At the time of writing, the little cut <a href=#>command</a> is approaching its 40th birthday, and we're still using it and writing about it today. I suppose cutting up text today is the same as it was 40 years ago. That is, a lot easier when you have the right tool to hand.</p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7qbvWraagnZWge6S7zGhucG1oZ4FwtM6wZK2nXarApnnToZxmpJmjwrl5wq6rZpuforqiusNo</p></div></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=./margaret-easley.html rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>Who is Margaret Easley dating? Margaret Easley boyfriend, husband</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=./remove-google-reading-list.html rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>How to Remove the Reading List From Google Chrome</p></a></div></nav></div><aside class=sidebar><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=./20-year-sentence-2003-murder-ephrata-html.html>20-year sentence for 2003 murder in Ephrata</a></li><li class=widget__item><a class=widget__link href=./3-ways-can-remove-unwanted-blog-pages-google.html>3 Ways You Can Remove Unwanted Blog Pages From Google</a></li><li class=widget__item><a class=widget__link href=./5-rewarding-benefits-of-playing-the-violin.html>5 Rewarding Benefits of Playing the Violin</a></li><li class=widget__item><a class=widget__link href=./article-fbcffa51-ae5b-5b24-ba42-7821fc682093-html.html>Child molesters are the sweetest people | Columnists</a></li><li class=widget__item><a class=widget__link href=./woman-quells-racist-row-getting-boobs-train-html.html>Woman quells racist row by getting her boobs out on train</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Categories</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=./categories/blog/>blog</a></li></ul></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2024 VivaX.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=https://assets.cdnweb.info/hugo/mainroad/js/menu.js></script>
<script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>